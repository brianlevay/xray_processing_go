<!DOCTYPE html>
<html>
    <head>
        <meta charset='UTF-8'>
        <title>Math Behind the Image Processing</title>
        <link rel='stylesheet' href='math.css'>
    </head>
    <html>
	<body>
	<section>
		<h1>Core Axis Determination</h1>
		
		<section>
			<h2>Binary Image</h2>
			<h3>Define core presence or absence based on threshold</h3>
			<p>if I<sub>raw</sub> &le; I<sub>threshold</sub></p>
			<p>I<sub>bin</sub> = 1.0</p>
			<p>if I<sub>raw</sub> &gt; I<sub>threshold</sub></p>
			<p>I<sub>bin</sub> = 0.0</p>
		</section>
		
		<section>
			<h2>Lateral Edge Detection</h2>
			<h3>Find where the core presence changes in the x-direction</h3>
			<p>I<sub>edge</sub>(i, j) = I<sub>bin</sub>(i, j+1) − I<sub>bin</sub>(i, j)</p>
		
			<h3>Determining the core edges</h3>
			<p>When I<sub>edge</sub>(i, j) = 1.0, you have the left edge of a feature. When I<sub>edge</sub>(i, j) = -1.0, you have the right edge of a feature. To determine the core edges, find all edges in a pixel row (fixed y). The edge points that give the largest gap from +1.0 (left edge) to -1.0 (right edge) are assumed to represent the edges of the core in that row, as long as the gap is exceeds a reasonable threshold.</p>
		</section>
		
		<section>
			<h2>Core Axis Estimation</h2>
			<p>The midpoint between the left and right core edge in each row is determined, and the points are fit using linear regression. The vertical pixel position (y) is used as the independent variable, and the horizontal pixel position (x) is used as the dependent variable. The regression line is compared against some limits to determine if it is reasonable, otherwise the axis is assumed to be vertical and centered.</p>
		</section>
	</section>
	
	<section>
		<h1>Thickness Modelling</h1>
	
		<section>
			<h2>Assumptions</h2>
			<p>The primary assumptions are that the cylinder axis is always at the same z and is aligned with the y axis. If it's not aligned with y, a simple xy axis rotation can be performed so that y' is aligned with the axis. This will keep the math the same (and simple).</p>
		</section>
	
		<section>
			<h2>Coordinate Systems</h2>
			<h3>Convert from initial coordinates to rotated coordinates, where y' is aligned with cylinder axis</h3>
			<p>x' = x cos&Theta; - y sin&Theta;</p>
			<p>y' = x sin&Theta; - y cos&Theta;</p>
			<p>z' = z</p>
		</section>
	
		<section>
			<h2>Fundamental Equations</h2>
			<h3>Equation of a cylinder, aligned with y' axis</h3>
			<p>(x' - x'<sub>a</sub>)<sup>2</sup> + (z' - z'<sub>a</sub>)<sup>2</sup> = r<sup>2</sup></p>
			
			<h3>Parametric equations of a ray</h3>
			<p>x' = x'<sub>p</sub> + u<sub>x'</sub>t</p>
			<p>y' = y'<sub>p</sub> + u<sub>y'</sub>t</p>
			<p>z' = z'<sub>p</sub> + u<sub>z'</sub>t</p>
			<p>&#10216; u<sub>x'</sub>, u<sub>y'</sub>, u<sub>z'</sub> &#10217; = unit vector for ray</p>
		</section>
	
		<section>
			<h2>Intersections Between a Ray and a Horizontal Plane</h2>
			<p>if u<sub>z'</sub> &ne; 0</p>
			<p>t<sub>h</sub> = (z'<sub>h</sub> - z'<sub>p</sub>) / u<sub>z'</sub></p>
			<p>else</p>
			<p>t<sub>h</sub> = undefined</p>
		</section>
	
		<section>
			<h2>Intersections Between a Ray and a Cylinder</h2>
			<h3>Substitution</h3>
			<p>(x'<sub>p</sub> + u<sub>x'</sub>t - x'<sub>a</sub>)<sup>2</sup> + (z'<sub>p</sub> + u<sub>z'</sub>t - z'<sub>a</sub>)<sup>2</sup> = r<sup>2</sup></p>
			
			<h3>Expand the full equation</h3>
			<p>At<sup>2</sup> + Bt + C = 0</p>
			<p>A = u<sub>x'</sub><sup>2</sup> + u<sub>z'</sub><sup>2</sup></p>
			<p>B = 2u<sub>x'</sub>(x'<sub>p</sub> - x'<sub>a</sub>) + 2u<sub>z'</sub>(z'<sub>p</sub> - z'<sub>a</sub>)</p>
			<p>C = x'<sub>p</sub><sup>2</sup> - 2x'<sub>p</sub>x'<sub>a</sub> + x'<sub>a</sub><sup>2</sup> + z'<sub>p</sub><sup>2</sup> - 2z'<sub>p</sub>z'<sub>a</sub> + z'<sub>a</sub><sup>2</sup> - r<sup>2</sup></p>
			
			<h3>Solve using the quadratic formula</h3>
			<p>det = B<sup>2</sup> - 4AC</p>
			<p>if det &gt; 0</p>
			<p>t<sub>c1</sub> = (-B - &radic;det) / 2A</p>
			<p>t<sub>c2</sub> = (-B + &radic;det) / 2A</p>
			<p>else</p>
			<p>t<sub>c1</sub>, t<sub>c2</sub> = 0</p>
		</section>
	
		<section>
			<h2>Path Lengths Through Whole Round and Half Round</h2>
			<h3>Whole round</h3>
			<p>if det &gt; 0</p>
			<p>thickness = t<sub>c2</sub> - t<sub>c1</sub>
			<p>else</p>
			<p>thickness = 0
			
			<h3>Half round</h3>
			<p>if det &gt; 0 and t<sub>h</sub> &lt; t<sub>c1</sub></p>
			<p>thickness = t<sub>c2</sub> - t<sub>c1</sub></p>
			<p>if det &gt; 0 and t<sub>c2</sub> &gt; t<sub>h</sub> &gt; t<sub>c1</sub></p>
			<p>thickness = t<sub>c2</sub> - t<sub>h</sub></p>
			<p>if det &le; 0 or t<sub>h</sub> &gt; t<sub>c2</sub></p>
			<p>thickness = 0</p>
		</section>
	</section>
	
	<section>
		<h1>Primary Calculations</h1>
	
		<section>
			<h2>Theoretical Background</h2>
			<h3>Fundamental material properties</h3>
			<p>&mu;(E) = mass attenuation coefficient of a material at a particular x-ray energy, based on the chemical composition</p>
			<p>&rho; = material density</p>
			<p>t = material thickness along the x-ray path</p>
			
			<h3>Basic equation for monochromatic x-ray transmission</h3>
			<p>I<sub>trans</sub>(E) = I<sub>0</sub>(E) * e<sup>-&mu;(E)&rho;t</sup></p>
			
			<h3>Equation for total x-ray transmission</h3>
			<p>&sum; I<sub>trans</sub>(E) = &sum; (I<sub>0</sub>(E) * e<sup>-&mu;(E)&rho;t</sup>)</p>
		</section>
		
		<section>
			<h2>Polychromatic X-Ray Approximation</h2>
			<h3>Approximated x-ray transmission</h3>
			<p>Based on numerical simulations, for a given material composition and source spectrum, a single effective mass attenuation coefficent can be used to approximate attenuation behavior for polychromatic x-rays.</p>
			<p>I<sub>trans</sub> = &sum; I<sub>trans</sub>(E)</p>
			<p>I<sub>0</sub> = &sum; I<sub>0</sub>(E)</p>
			<p>I<sub>trans</sub> &approx; I<sub>0</sub> * e<sup>-&mu;<sub>eff</sub>*&rho;*t</sup></p>
		
			<h3>Estimating effective material properties</h3>
			<p>If our detector is over-saturated, we don't know I<sub>0</sub> (the total number of x-rays from the source), we only know I<sub>max</sub>, the value at which the detector saturates. The impact of using I<sub>max</sub> instead of I<sub>0</sub> is that all of our &mu;<sub>eff</sub>*&rho;*t values will be shifted by a constant value. </p>
			<p>&mu;<sub>eff</sub>*&rho;*t &approx; ln(I<sub>max</sub> + 1.0) - ln(I<sub>trans</sub> + 1.0)</p>
			<p>We add 1.0 to I<sub>trans</sub> to prevent undefined behavior when I<sub>trans</sub> = 0, and we add 1.0 to I<sub>max</sub> to preserve the fact that &mu;<sub>eff</sub>*&rho;*t = 0 when I<sub>trans</sub> is equal to I<sub>max</sub>.</p>
		
			<h3>Compensating for thickness</h3>
			<p>We can remove the impact of thickness variations by normalizing to a constant reference thickness (in this case, the maximum core thickness). Outside the modelled footprint of the core, we leave the &mu;<sub>eff</sub>*&rho;*t values unchanged. The reason that we adjust to a constant thickness rather than just dividing by the thickness is that it better preserves the relationships between pixel values within the core footprint and pixel values outside of the core, if other objects are present (such as references or standards).</p>
			<p>&mu;<sub>eff</sub>*&rho;*t<sub>ref</sub> &approx; (&mu;<sub>eff</sub>*&rho;*t) * (t<sub>ref</sub> / t<sub>model</sub>)
			<p>t<sub>model</sub> = distances through the core that x-rays have to travel to reach each pixel</p>
			<p>t<sub>ref</sub> = maximum vertical distance through core (diameter or radius)</p>
		</section>
	</section>
	
	<section>
		<h1>Contrast Enhancement</h1>
		
		<section>
			<h2>Requirements</h2>
			<p>Must be a function that is continuous over the input range and through the peak! Using two different functions around the peak leads to strong anomalies and unstable behavior at the peak itself, which creates artifacts over large swaths of the images.</p>
		</section>
		
		<section>
			<h2>Histogram Stretching and Centering</h2>
			<h3>Values</h3>
			<p>O<sub>val</sub> = &mu;<sub>eff</sub>*&rho;*t<sub>max</sub></p>
			<p>O<sub>min</sub> = ln(I<sub>max</sub> + 1.0) - ln(I<sub>high</sub> + 1.0)</p>
			<p>O<sub>peak</sub> = ln(I<sub>max</sub> + 1.0) - ln(I<sub>peak</sub> + 1.0)</p>
			<p>O<sub>max</sub> = ln(I<sub>max</sub> + 1.0) - ln(I<sub>low</sub> + 1.0)</p>
			
			<h3>Normalization</h3>
			<p>if O<sub>min</sub> &le; O<sub>val</sub> &le; O<sub>max</sub></p>
			<p>X = (O<sub>val</sub> - O<sub>min</sub>) / (O<sub>max</sub> - O<sub>min</sub>)</p>
			<p>if O<sub>val</sub> &lt; O<sub>min</sub></p>
			<p>X = 0.0</p>
			<p>if O<sub>val</sub> &gt; O<sub>max</sub></p>
			<p>X = 1.0</p>
			
			<h3>Using a polynomial to stretch the X values and center the peak at 0.5</h3>
			<p>X<sub>peak</sub> = (O<sub>peak</sub> - O<sub>min</sub>) / (O<sub>max</sub> - O<sub>min</sub>)</p>
			<p>0.5 = X<sub>peak</sub><sup>n</sup></p>
			<p>n = ln(0.5) / ln(X<sub>peak</sub>)</p>
			<p>P = X<sup>n</sup></p>
			
			<h3>Using a sine function to stretch central values and compress edge values</h3>
			<p>S(X) = 0.5 * sin(&pi; * (X − 0.5)) + 0.5</p>
			<p>S(P) = 0.5 * sin(&pi; * (P − 0.5)) + 0.5</p>
			
			<h3>Avoiding too much distortion</h3>
			<p>When X<sub>peak</sub> is far from 0.5, using S(P) can distort the spectrum too much and cause spectral artifacts. Using S(X) will not shift the peak at all, however, leaving too much original skew. Using a weighted mixture of S(P) and S(X) allows us to shift the peak and stretch the histogram without causing poor behavior under extreme skew.</p>
			<p>w = 1.0 − abs(2.0 * (X<sub>peak</sub> − 0.5))<sup>2</sup></p>
			<p>Y = w * S(P) + (1 − w) * S(X)</p>
			
			<h3>Converting to pixel values and reversing greyscale</h3>
			<p>I<sub>proc</sub> = I<sub>max</sub> * (1 - Y)</p>
		</section>
		
	</section>
	
	</body>
</html>
